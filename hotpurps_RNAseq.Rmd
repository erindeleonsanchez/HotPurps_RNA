---
title: "hotpurps_RNAseq"
author: "Erin de Leon Sanchez"
date: "1/25/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(root.dir = '~/Documents/GitHub/HotPurps_RNA/')

library(dplyr)
library(edgeR)
library(DESeq2)
library(tidyverse)
library(limma)
library(arrayQualityMetrics) 
# library(pheatmap)
library(ape) # for pcoa
library(vegan) #vegdist
library(statmod)
library(reshape2)
library(Rmisc)
library(mediation)
# library(ggforce)
# library(ggpubr)
# library(lme4)
# library(nadiv)
library(Matrix)
# library(lme4qtl)
# library(brms)
# library(bayestestR)
# library(ggExtra)
# library(GenomicRanges)
# library(lmtest)


```

# Combining featureCounts .txt files
```{r}
# 
myfiles=list.files(path = "featureCounts_gene_id_pairs/txt_files", pattern = "*.txt")  #read in list of featureCounts .txt files

x <- readDGE(myfiles, path = "featureCounts_gene_id_pairs/txt_files/", skip=1, columns=c(1,7)) # need skip=1

counts=as.data.frame(x$counts)

# Shortening column names

colnames(counts)<-substr(colnames(counts), 1,5)

colnames(counts)<-gsub(colnames(counts), pattern = "_s", replacement = "")

# saving combined counts file as .txt 
write.table(counts, file = "combined_featureCounts_HP.txt", sep="\t")
write.csv(counts, "combined_featureCounts_HP.csv")

# counts$gene_id<-row.names(counts) this added a column called gene_id but don't need this

# Plot distribution of unfiltered read counts across all samples 
ggplot(data = data.frame(rowMeans(counts)),
       aes(x = log(rowMeans.counts.))) +
  geom_histogram(fill = "grey") +
  theme_classic() +
  labs(title = "Distribution of unfiltered reads") +
  labs(y = "Density", x = "log raw read counts",
  title = "Read count distribution: untransformed, unnormalized, unfiltered")

```

#Tests of differential expression 
```{r}
# Create maternal treatment variable - this basically "extracts" that the first letter of the treatment which is the maternal treatment
Mat = as.vector(sapply(colnames(counts), 
                       function(col) substr(col, 1, 1))) 

# Create developmental treatment variable - this basically "extracts" that the second letter of the treatment which is the developmental treatment
Dev = as.vector(sapply(colnames(counts),
                       function(col) substr(col, 2, 2)))

Rep = as.vector(sapply(colnames(counts),
                      function(col) substr(col, 3,3)))

# Create df of predictor variables
targets_gc <- data.frame(Mat = Mat,
                         Dev = Dev, 
                         Rep = Rep)

targets_gc$grouping <- paste0(targets_gc$Mat, 
                             targets_gc$Dev,
                             sep="") # the grouping column groups by bucket i.e., CC,CW, WC, WW

# Round counts (if necessary) for use in edgeR
data_input_gc <- sapply(counts,as.numeric)

row.names(data_input_gc) <- row.names(counts)

data_input_gc <- as.data.frame(round(data_input_gc))

```

# Making DGEList and MDS plot
```{r}
# Make DGElist

DGEList <- DGEList(counts = data_input_gc, 
                   group = targets_gc$grouping, 
                  remove.zeros = T) #removed 5302 rows with all 0

# Let's remove genes with less then 0.5 cpm (this is ~10 counts in the count file) in no fewer than 8 samples --> 75% of our samples. Could use 4 for our smallest group size and compare
DGEList_keep <- rowSums(cpm(DGEList) > 0.5) >= 8

# How many genes are removed by read count filter?
table(DGEList_keep)
# when I run it with 8:
#DGEList_keep
#FALSE  TRUE 
#10456 17224 

# when I run it with 4:
# DGEList_keep
# FALSE  TRUE 
#  8614 19066 



# Filter and set keep.lib.sizes = F to have R recalculate library sizes after filtering
DGEList <- DGEList[DGEList_keep, 
                   keep.lib.sizes = FALSE]

# Create library size normalization factors
DGEList <- calcNormFactors(DGEList)


# CPM conversion and log^2 transformation of read counts
DGEList_log <- cpm(DGEList,
                   log = TRUE, 
                   prior.count = 2)

ggplot(data = data.frame(rowMeans(DGEList_log)), 
       aes(x = rowMeans.DGEList_log.) ) +
  geom_histogram(fill = "grey") +
  theme_classic() +
  labs(y = "Density", x = "Filtered read counts (logCPM)",
       title = "Distribution of normalized, filtered read counts")

# MDS of normalized gene read counts
MDS <- plotMDS(DGEList_log)

# Print MDS plot
MDS
```

# PCA Plot

```{r}
#PCA

# Export pcoa loadings
dds.pcoa = pcoa(vegdist(t(DGEList_log),
                          method = "euclidean") / 1000)

# Create df of MDS vector loading
scores <- dds.pcoa$vectors

## Plot pcoa loadings of each sample, groouped by time point and pCO2 treatment

# Calculate % variation explained by each eigenvector
percent <- dds.pcoa$values$Eigenvalues
cumulative_percent_variance <- (percent / sum( percent)) * 100

# Prepare information for pcoa plot, then plot
color <- c("steelblue1", "tomato1", "goldenrod1")
par(mfrow = c(1, 1))
plot(
  scores[, 1],
  scores[, 2],
  cex = .5,
  cex.axis = 1,
  cex.lab = 1.25,
  xlab = paste("PC1, ", round(cumulative_percent_variance[1], 2), "%"),
  ylab = paste("PC2, ", round(cumulative_percent_variance[2], 2), "%")
  )

# Add visual groupings to pcoa plot
ordihull(
  scores,
  as.factor(targets_gc$grouping),
  border = NULL,
  lty = 2,
  lwd = .5,
  label = F,
  col = color,
  draw = "polygon",
  alpha = 100,
  cex = .5
  )

ordispider(scores, as.factor(targets_gc$grouping), # can choose how they're grouped
           label = T, col = color, )

ordilabel(scores, cex = 0.5) # Label sample IDs

```

#Outlier detection
```{r}

# Create DESeq2 object required for arrayqualitymetrics
counts_df <- as.data.frame(DGEList)


dds <- DESeqDataSetFromMatrix(counts_df,
                              colData = targets_gc,
                              design = formula(~ 1 + Mat + Dev))

# Filter DESeq object
dds_keep <- rowSums(cpm(dds) > 0.5) >= 8
dds <- dds[dds_keep]

# Outlier tests
#This function calculates a variance stabilizing transformation (VST) from the fitted dispersion-mean relation(s) and then transforms the count data (normalized by division by the size factors or normalization factors), yielding a matrix of values which are now approximately homoskedastic (having constant variance along the range of mean values). The transformation also normalizes with respect to library size. The rlog is less sensitive to size factors, which can be an issue when size factors vary widely. These transformations are useful when checking for outliers or as input for machine learning techniques such as clustering or linear discriminant analysis.

vsd <- varianceStabilizingTransformation(dds, blind=TRUE)
#every gene contains at least one zero

e <- ExpressionSet(assay(vsd), AnnotatedDataFrame(as.data.frame(colData(vsd))))

arrayQualityMetrics(e, intgroup=c("Mat","Dev"), force=T)
# there are no outliers. Tested to see if WC2_2 was an outlier and it was not 
```


```{r}
# Export DGEList_keep
save(DGEList_keep,
     file = "DGEList_keep.Rdata")

```

```{r}
# Create model design that includes maternal and developmental effects and set intercept to 0
design_multi_gc <- model.matrix(~0 + Mat + Dev + Mat:Dev) 
colnames(design_multi_gc)[4] <- "MatW_DevW"

# Filter and normalize count matrix input
gene_counts_matrix <- as.matrix(data_input_gc)

DGEList <- DGEList(counts = gene_counts_matrix, 
                   group = targets_gc$grouping, # need to make sure im grouping correctly, doing it by buckets rn
                   remove.zeros = T)

DGEList <- DGEList[DGEList_keep, 
                   keep.lib.sizes = FALSE]

DGEList <- calcNormFactors(DGEList)

# Estmate mean dispersal for use in plotting common dispersal against tagwise dispersal
DGEList <- estimateGLMCommonDisp(DGEList, 
                                 design_multi_gc)

# Estmate robust, Bayesian dispersal per gene for estimating regression parameters for glmQL and differential expression
DGEList <- estimateGLMRobustDisp(DGEList, 
                                 design_multi_gc) 

# Plot tagwise dispersal and impose w/mean dispersal and trendline
# the BCV plot visualizes the dispersion parameter fitted to individual genes (black dots with an associated mean expression level and maximum likelihood estimation (MLE) of the dispersion), fitted across gene expression level (blue trendline), and averaged across the entire transcriptome (red horizontal line)
plotBCV(DGEList) 

# Fit a robust, multifactorial quasi-likelihood glm to normalized read counts
# this function detects the gene-specific variability above and below the overall level
fit_gc <- glmQLFit(DGEList, 
                   design_multi_gc, 
                   robust = TRUE)

# Plot shrinkage of Bayesian quasi-likelihood dispersion to visualize statistical power of DE analysis
# this is a plot of the genewise QL dispersion against the gene abundance
plotQLDisp(fit_gc) # High shrinkage / high statistical power across DE tests
```

```{r}
## Pairwise comparison of parental differential expression

# Design contrast between samples based on maternal effect
# The makeContrast function creates the contrast of (-1, 1) which subtracts the first parameter estimate (mean expression of cold moms) from the second parameter estimate (mean expression of warm moms).
con_Mom <- makeContrasts(con_Mat_cons = MatC - MatW,
                            levels = design_multi_gc)

# Apply quasi-likelihood F test to incorporate Bayesian tagwise dispersion estimates as parameter for DEG analysis
maternal_QLFT <- glmQLFTest(fit_gc, 
                            contrast = con_Mom)

# Plot maternal logFC across logCPM (fdr < 0.05)
#Here, we're visualizing the difference in log-fold-change of gene expression between cold moms and warm moms
plotMD(maternal_QLFT)

# How many significant DEGs? 2405
summary(decideTestsDGE(maternal_QLFT, 
                       adjust.method = "fdr",
                       p.value = 0.05))
#       1*MatC -1*MatW
# Down              485
# NotSig          16354
# Up                385

# Filter for significance and logFC cutoff (doubling of fold change or logFC of 1)
maternal_QLFT_cutoff <- topTags(maternal_QLFT, 
                                n = (485 + 385), # these #s are the # of up & down regulated genes
                                adjust.method = "fdr",
                                p.value = 0.05)

# Create df of logFC and sign cutoff DEGs
maternal_QLFT_cutoff_df <- data.frame(maternal_QLFT_cutoff$table)
maternal_QLFT_fc_cutoff_df <- maternal_QLFT_cutoff_df[!(abs( maternal_QLFT_cutoff_df$logFC) < 1),]

# Count total DEGs with logFC cutoff
nrow(maternal_QLFT_cutoff_df) # Without logFC cutoff = 870 DEGs
nrow(maternal_QLFT_fc_cutoff_df) # With logFC cutoff = 197 DEGs

```

```{r}

## Pairwise comparison of developmental differential expression

# Pairwise comparison of developmental differential expression
# need to check devW vs devC
con_Dev <- makeContrasts(con_Dev_cons = DevW, 
                         levels = design_multi_gc)

# Apply quasi-likelihood F test to incorporate Bayesian tagwise dispersion estimates as parameter for DEG analysis
dev_QLFT <- glmQLFTest(fit_gc,
                       contrast = con_Dev)

# Plot dev logFC across logCPM (fdr < 0.05) Here, we're visualizing the difference in log-fold-change of gene expression between larvae from cold developmental conditions and warm developmental conds
plotMD( dev_QLFT )

# How many significant DEGs? 
summary( decideTestsDGE( dev_QLFT, 
                         adjust.method = "fdr",
                         p.value = 0.05 ) )
#       1*DevW
# Down     1365
# NotSig  14105
# Up       1754

# Filter for significance and logFC cutoff
dev_QLFT_cutoff <- topTags(dev_QLFT, 
                                n = (1365 + 1754), 
                                adjust.method = "fdr",
                                p.value = 0.05)

# Create df of logFC and sig cutoff DEGs (doubling of fold change or logFC of 1)
dev_QLFT_cutoff_df <- data.frame( dev_QLFT_cutoff$table )
dev_QLFT_fc_cutoff_df <- dev_QLFT_cutoff_df[ !( abs( dev_QLFT_cutoff_df$logFC ) < 1 ), ]

# Count total DEGs with logFC cutoff
nrow(dev_QLFT_cutoff_df) # Without logFC cutoff = 3119 DEGs
nrow(dev_QLFT_fc_cutoff_df) # With logFC cutoff = 622 DEGs

## Make Fig2B (MD plot)
# Create plotting df
dev_QLFT$table$Effect <- "Developmental"
maternal_QLFT$table$Effect <- "Transgenerational"

dev_QLFT$table$FDR <- p.adjust(dev_QLFT$table$PValue, method = "fdr")
maternal_QLFT$table$FDR <- p.adjust(maternal_QLFT$table$PValue, method = "fdr")

QLFT <- rbind(dev_QLFT$table, maternal_QLFT$table)
QLFT$Dir <- ifelse(QLFT$logFC > 0 & QLFT$FDR < 0.05, "Up", 
                             ifelse(QLFT$logFC < 0 & QLFT$FDR < 0.05,
                                    "Down", "None"))

QLFT$Effect = factor(
  QLFT$Effect,
  levels=c('Transgenerational','Developmental'))

QLFT$Dir = factor(
  QLFT$Dir,
  levels=c('Down','Up', 'None'))

# Plot Fig 1, which will be LogFCs of differential expression plotted against baseline transcript abundance. Significant upregulation in red and downregulation in blue

Fig1 <- ggplot(data = QLFT,
                aes(x = logCPM, y = logFC, size = Dir, color = Dir)) +
  geom_point() +
  scale_size_manual(values = c(1, 1, .1), guide = "none") +
  scale_color_manual(values = c("blue", "red", "black"), guide = "none") +
  facet_grid(Effect~.) +
  theme_classic(base_rect_size = 0, base_size = 20)

Fig1

```

```{r}
# #Can compare/visualize gene counts between treatments in histogram
# # literally come back to this but I want to do this
# design_multi_gc2 <- model.matrix(~0 + Mat + Dev) 
# 
# # Filter and normalize count matrix input
# gene_counts_matrix <- as.matrix(design_multi_gc2)
# 
# DGEList <- DGEList(counts = gene_counts_matrix, 
#                    group = targets_gc$grouping, # need to make sure im grouping correctly, doing it by buckets rn
#                    remove.zeros = T)
# 
# DGEList <- DGEList[DGEList_keep, 
#                    keep.lib.sizes = FALSE]
# 
# DGEList <- calcNormFactors(DGEList)
# 
# v1 <- voomWithQualityWeights(DGEList, design=design_multi_gc, lib.size=DGEList$group$lib.size, plot = TRUE)
# 
# fit <- lmFit(v1,design_multi_gc) 
# fit <- eBayes(fit) 
# 
# All_data_output <- topTable(fit,coef=ncol (design_multi_gc), adjust.method="BH", number=2000, p.value=0.05) 
# write.table(All_data_output, "All_data_output.txt")
# 
# # Define a contrast matrix to make all pairwise comparisons of interest
# cont_matrix_all <- makeContrasts(con_all = MatC - MatW, DevW,
#                             levels = design_multi_gc)
# cont_matrix_all
# 
# # Extract the linear model fit for the contrasts
# fit2 <- contrasts.fit(fit, cont_matrix_all)
# fit2 <- eBayes(fit2)
# plotSA(fit2)
# 
# # Assess differential expression
# colnames(fit2)
# Allcomp <- topTable(fit2,adjust="BH", number=Inf)

```


```{r}
## Interactive effects 

# Pairwise comparison of developmental differential expression
# need to check devW vs devC
con_int <- makeContrasts(int_cons = MatW_DevW, 
                         levels = design_multi_gc)

# Apply quasi-likelihood F test to incorporate Bayesian tagwise dispersion estimates as parameter for DEG analysis
int_QLFT <- glmQLFTest(fit_gc,
                       contrast = con_int)

# Plot dev logFC across logCPM (fdr < 0.05) Here, we're visualizing the difference in log-fold-change of gene expression between larvae from cold developmental conditions and warm developmental conds
plotMD(int_QLFT)

# How many significant DEGs? 
summary(decideTestsDGE(int_QLFT, 
                         adjust.method = "fdr",
                         p.value = 0.05))
#       1*MatW_DevW
# Down     0
# NotSig  17224
# Up       0

```

# Structural equation models

First, wrangle normalized read counts and covariates into tabular format

```{r}

# Create cpm df for regression against phenotypic data
logCPM_df <- as.data.frame(DGEList_log)

# Create tabularized df containing all replicates using 'melt'
logCPM_df$geneid <- row.names(logCPM_df)

tab_exp_df <- melt(logCPM_df,
                   id = c("geneid"))

# Create tabularized phenotypic df
lipid_df <- read.csv("hotpurps_egg_lipid.csv")
protein_df <- read.csv("hotpurps_egg_protein.csv")
larv_morph_df <- read.csv("embryo_morphometrics.csv")

# Calc mean lipid and protein by maternal treatment
egg_df <- data.frame(
  Mat = c("C", "W"),
  lipid = c(mean(filter(lipid_df, Mat == "C")[,4]),
            mean(filter(lipid_df, Mat == "W")[,4])),
  prot = c(mean(filter(protein_df, Mat == "C")[,5]),
           mean(filter(protein_df, Mat == "W")[,5]))
)

# Calc mean morphs per bucket grouped by stage
hb_sum <- summarySE(measurevar = "area_mm2",
                          groupvars = c("bucket"),
                          data = filter(larv_morph_df, 
                                        stage == "HB"))[,c(1,3)]

eg_sum <- summarySE(measurevar = "area_mm2",
                          groupvars = c("bucket"),
                          data = filter(larv_morph_df, 
                                        stage == "EG"))[,c(1,3)]

pr_sum <- summarySE(measurevar = "area_mm2",
                          groupvars = c("bucket"),
                          data = filter(larv_morph_df, 
                                        stage == "PR"))[,c(1,3)]

# Merge egg data with GE df
tab_exp_df$Mat <- substr(tab_exp_df$variable, 1, 1)
tab_exp_df$Dev <- substr(tab_exp_df$variable, 2, 2)

tab_morph_df <- merge(tab_exp_df,
                      egg_df,
                      by = "Mat")

# Merge egg x GE df with larval morphs
tab_prism_df <- merge(tab_morph_df,
                      pr_sum,
                      by.x = "variable", 
                      by.y = "bucket")

tab_hb_df <- merge(tab_morph_df,
                      hb_sum,
                      by.x = "variable", 
                      by.y = "bucket")

# Fit structural equation model: 
# (i) dev -> (1-abnorm), GE and (ii)  dev -> (1-abnorm)

# Fit prism SEM model A: time elapse = 
lm1s <- dlply(tab_prism_df, c("geneid"), function(df) 
lm(value ~ Mat + Dev, data = df))

lm2s <- dlply(tab_prism_df, c("geneid"), function(df) 
lm(area_mm2 ~ value + Mat, data = df))

# Fit prism SEM model A: time elapse = 
lm1s_hb <- dlply(tab_hb_df, c("geneid"), function(df) 
lm(value ~ Mat + Dev, data = df))

lm2s_hb <- dlply(tab_hb_df, c("geneid"), function(df) 
lm(area_mm2 ~ value + Mat, data = df))

```

## HB SEMs

```{r}

# Function to perform mediation analysis
run_mediation_hb <- function(index) {
  tryCatch({
    summary(mediate(lm1s_hb[[index]], lm2s_hb[[index]], 
                     boot = TRUE, sims = 10, 
                     treat = "Mat", mediator = "value"))
  }, error=function(e){paste("Error in index", index, ":", e$message)}) # Return the error message
}

# Determine the number of cores
no_cores <- detectCores() - 1

# Create a cluster
cl <- makeCluster(no_cores)
clusterEvalQ(cl, library(mediation))
clusterExport(cl, varlist = c("lm1s_hb", "lm2s_hb", "run_mediation_hb"))

# Run mediation in parallel
mat_mediations_hb <- parLapply(cl, 1:length(lm1s), run_mediation_hb)

# Stop the cluster
stopCluster(cl)

names(mat_mediations_hb) <- names(lm1s_hb)

# Save and reload mediation
save(mat_mediations_hb, file = "03082024_mat_mediations_hb.Rdata")

```

```{r}

# Extract indirect effect estimates
ind_est_hb <- list() 

for (i in 1:length(mat_mediations_hb)) {
  # Check if it's a list/data.frame and contains 'd0'
  if ((is.list(mat_mediations_hb[[i]]) || is.data.frame(mat_mediations_hb[[i]])) && !is.null(mat_mediations_hb[[i]]$d0)) {
    # Assuming 'd0' can be converted directly to a data.frame
    temp_df <- mat_mediations_hb[[i]]$d0
    
    # Transpose and then store in 'ind_est_d'
    ind_est_hb[[i]] <- temp_df
  } else {
    # Optionally, store NA or an empty data frame to keep consistent list lengths
    ind_est_hb[[i]] <- NA  # Or, data.frame() for an empty data frame
  }
}

names(ind_est_hb) <- names(mat_mediations_hb)

ind_est_hb_df <- as.data.frame(t(bind_rows(ind_est_hb, .id = "column_label")))

# Change geneids to transcript id's for go annotation
ind_est_hb_df$column_label = rownames(ind_est_hb_df)

ind_est_hb_df <- merge(ind_est_hb_df,
                      data.frame(column_label = unique$gene,
                                 transcript = unique$Name),
                      by = "column_label",
                      all.x = TRUE)

# Export gomwu df of coefficients
write.csv(data.frame(geneid = paste("rna-", ind_est_hb_df$transcript, sep = ""),
                     coef = ind_est_hb_df[,2]),
          file = "GO_MWU-master/mat_hb_ind_gomwu.csv",
          row.names = FALSE) # Resave the csv inexcel before GOMWU run

```


## Prism SEMs

```{r}

library(parallel)
library(profvis)

# Function to perform mediation analysis
run_mediation <- function(index) {
  tryCatch({
    summary(mediate(lm1s[[index]], lm2s[[index]], 
                     boot = TRUE, sims = 10, 
                     treat = "Mat", mediator = "value"))
  }, error=function(e){paste("Error in index", index, ":", e$message)}) # Return the error message
}

# Determine the number of cores
no_cores <- detectCores() - 1

# Create a cluster
cl <- makeCluster(no_cores)
clusterEvalQ(cl, library(mediation))
clusterExport(cl, varlist = c("lm1s", "lm2s", "run_mediation"))

# Run mediation in parallel
mat_mediations_b <- parLapply(cl, 1:length(lm1s), run_mediation)

# Stop the cluster
stopCluster(cl)

names(mat_mediations_b) <- names(lm1s)

# Save and reload mediation
save(mat_mediations_b, file = "03082024_mat_mediations_b.Rdata")

```

```{r}

load("03082024_mat_mediations.Rdata")

# Extract p-values for indirect effects: E -> M -> GE
ind_p_d <- list()

for (i in 1:length(mat_mediations)) {
  if (is.list(mat_mediations[[i]]) || is.data.frame(mat_mediations[[i]])) {
    if (!is.null(mat_mediations[[i]]$d0.p)) {
      ind_p_d[[i]] <- mat_mediations[[i]]$d0.p
    } else {
      ind_p_d[[i]] <- NA  # or some other placeholder to indicate missing data
    }
  } else {
    ind_p_d[[i]] <- NA  # or some other placeholder
  }
}

names(ind_p_d) <- names(mat_mediations)

ind_p_d_df <- as.data.frame(t(bind_rows(ind_p_d, .id = "column_label")))

# Extract indirect effect confidence intervals
ind_ci_d <- list() 

for (i in 1:length(mat_mediations)) {
 ind_ci_d[[i]] <- data.frame(t(as.data.frame(mat_mediations[[i]]$d0.ci)))
}
names(ind_ci_d) <- names(mat_mediations)

# Extract indirect effect estimates
ind_est_d <- list() 

for (i in 1:length(mat_mediations)) {
  # Check if it's a list/data.frame and contains 'd0'
  if ((is.list(mat_mediations[[i]]) || is.data.frame(mat_mediations[[i]])) && !is.null(mat_mediations[[i]]$d0)) {
    # Assuming 'd0' can be converted directly to a data.frame
    temp_df <- mat_mediations[[i]]$d0
    
    # Transpose and then store in 'ind_est_d'
    ind_est_d[[i]] <- temp_df
  } else {
    # Optionally, store NA or an empty data frame to keep consistent list lengths
    ind_est_d[[i]] <- NA  # Or, data.frame() for an empty data frame
  }
}

names(ind_est_d) <- names(mat_mediations)

ind_est_d_df <- as.data.frame(t(bind_rows(ind_est_d, .id = "column_label")))

names(ind_p_vd) <- names(mat_mediations)

for (i in 1:length(ind_p_d)) {
 new_value_d <- as.numeric(ind_p_d[[i]])
}

ind_ci_d_df <- bind_rows(ind_ci_d, .id = "column_label")

# Create df with geneid and indirect effect pvals
ind_p_dfd <- as.data.frame(t(data.frame(ind_p_vd)))

ind_p_dfd$fdr <- p.adjust(ind_p_dfd$V1, method = "fdr")

nrow(filter(ind_p_dfd, fdr < 0.05)) # 2332; 14% of all genes gave mediated fitness effect)
nrow(filter(ind_p_dfd, fdr < 0.05)) / nrow(ind_p_dfd)

# Filter to include only transcripts with significant mediation parameter estimate
sig_mat_meth_dfd <- filter(ind_ci_d_df, X2.5. > 0 & X97.5. > 0 | X2.5. < 0 & X97.5. < 0) # 66 mat indirect genes
nrow(sig_mat_meth_dfd) # 2671

# 15.9% of genes has mediated fitness effect
nrow(sig_mat_meth_dfd) / nrow(ind_p_dfd)

# How many mediation effects are positive vs. negative
nrow(filter(sig_mat_meth_dfd, X2.5. > 0)) #845 are positive

```

```{r}
## Export results for functional enrichment analysis

library(rtracklayer)

spour5.0_gff <- as.data.frame(import("genome_resources/sp5_0_GCF.gff3"))

spour5.0_RNAs <- filter(spour5.0_gff, type == "mRNA")
unique <- spour5.0_RNAs[!duplicated(spour5.0_RNAs$gene), ]

ind_est_d_df$column_label = rownames(ind_est_d_df)

ind_est_d_df <- merge(ind_est_d_df,
                      data.frame(column_label = unique$gene,
                                 transcript = unique$Name),
                      by = "column_label",
                      all.x = TRUE)

# Export gomwu df of coefficients
write.csv(data.frame(geneid = paste("rna-", ind_est_d_df$transcript, sep = ""),
                     coef = ind_est_d_df[,2]),
          file = "GO_MWU-master/mat_lipid_ind_gomwu.csv",
          row.names = FALSE)

```

# Functional enrichment analyses

```{r}

# GO enrichments using Mann Whitney U tests
setwd("~/Documents/GitHub/HotPurps_RNA/GO_MWU-master/")

#Now we multiply them together into a new column

## Ok we also want to bring in our annotations
#I would suggest putting a GO_MWU folder into your working directory for these steps. There is some stuff to download such as the obo files 
#See https://github.com/z0on/GO_MWU

# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.
# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 
# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.
# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.
# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.
# Stretch the plot manually to match tree to text

# Mikhail V. Matz, UT Austin, February 2015; matz@utexas.edu

################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.

# Edit these to match your data file names: 
input = "mat_hb_ind_gomwu.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="goAnnot_spur5.0.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")

# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1, # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=10,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.25,
	Alternative = "g") # threshold for merging similar (gene-sharing) terms. See README for details.
	#Alternative="g") # # threshold for merging similar (gene-sharing) terms. See README for details.
           #	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
           #	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
           #	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
# do not continue if the printout shows that no GO terms pass 10% FDR.

quartz(quartz.options(width=5, height=3))
results=gomwuPlot(input, goAnnotations, goDivision,
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
	absValue=.001,
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
	level2=0.01, # FDR cutoff to print in regular (not italic) font.
	level3=0.001, # FDR cutoff to print in large bold font.
	txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
	treeHeight=1,# height of the hierarchical clustering tree
  colors=c("salmon1","royalblue","lightcoral","skyblue") # these are default colors, un-remar and change if needed
)

# manually rescale the plot so the tree matches the text 
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.  

results
  
```

```

### 03/082024 Results summary from SB

Results:
* ~2600 genes show a mediating effect of maternal treatment on prism body size, such that DE of the gene induced by maternal heat stress may drive increases in prism size. Of these,  ~800 were upregulated and ~1800 were downregulated.

* A gene ontology mann whitney U test shows that there are GO terms enriched for downregulated genes that mediated a positive effect of maternal heat stress on prism body size. There was no functional enrichment among upregulated genes.

* GO terms localized to the following cellular components: golgi apparatus, cytoskeleton, microtubule cytoskeleton, supramolecular complex, and supramolecular polymer.

* Enriched molecular functions include: structural constituent of cytoskeleton, FMB binding, and oxidoreductase activity.

* No biological process GO terms were enriched. Together, this suggests that the positive effect of maternal conditioning on prism size is related to downregulation of pathways responsible for antioxidation and building cytoskeletal macromolecules. Both reactive oxygen stress and cytoskeletal macromolecule synthesis are important components of golgi body function.

* Interestingly, none of these pathways relate to protein or lipid metabolism, which was my a priori expectation. We can repeat the above analysis for hatched blastula and early gastrula areas and report those results alongside the prism effects. One possibility may be that protein provisioning of eggs (and maybe lipid provisioning) affect protein/lipid metabolism in embryos but this effect is washed out by the time you get to prism.

